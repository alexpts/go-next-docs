# Быстрый старт

[[toc]]
---

::: tip Предыстория
Next является портированой версией микрофреймворка [php-next2](https://github.com/alexpts/php-next2).
:::

## Hello World

Минимальное приложение выглядит так:

@[code go{11-15}](../../examples/hello-world.go)

## Glossary

#### Middleware

Middleware - это часть приложения, которая отвечает за конкретную единицу логики в обработке
request/response.


#### Layer

Это абстракция которая является по сути middleware. Layer может иметь как 1 обработчик, так и несколько, чтобы декомпозировать на более мелкие части код.


#### Application

Приложение является самым высоким уровнем и реалзиует полноую обработку запроса.
Приложение это набор Layers, которые определяются для каждого http запроса индивидуально.
Задача приложения получить на входе http request и создать http response.

Приложение осознано сводит число сущностей к минимуму, чтобы оставаться действительно простым, понятным и надежным.
Основное понятие с которым придется постоянно работать это Layer (Слой).

Приложеине получает на вход объект `fasthttp.RequestCtx` и прогоняет через все обработчики слоев. Какие именно
слои примут частие в обработке запроса определяется метаифнормацией слоя. Семантически можно выделить следующие типы
слоев:

- Активация на любом запросе
- Активация по http методу
- Активация по соответствию uri в регулярном выражении
- Актичация по кастомной стратегии

::: details Собственные стратегии
Из коробки идет минимальный набор стратений (по http методу и поиск по uri). Можно дополнительно реализовать любые
кастомные правила, по которым будет принято решение активировать ли слоя для обработки запроса или нет. Для этого нужно
добавить свою реализацию `next.ResolverContract`
:::

## Layers Store

Приложение `App` хранит в себе в свойстве `LayersStore` хранилище слоев.
Хранилище слоев позволяет добавлять обрабочтики к приложению посредством методов `AddLayer`, `Get`, `Post` и др.
Все методы `LayersStore` также можно вызывать на приложении, если хочется писать лаконично.

```go
    app := next.NewApp()
	
    app.Use(layer.Config{}, func(ctx *next.HandlerCxt) error {
      ctx.Response.AppendBodyString(`Hello`)
      return nil
    })
```

### Handler

Функция обработчик в общем случае принмает 1 аргумент.

```go
type Handler func(ctx *layer.HandlerCxt)
```

::: tip Context
Контекст - это связующая часть между всеми слоями. Базовый контекст хранит request, response и позволяет получить доступ
к текущему слою (Layer) в runtime.
:::

Чтобы делегировать управление следующему обработчику, нужно вызвать метод `Next` на объекте контекста обработчика:
```go
    app := next.NewApp()

    app.Use(layer.Layer{}, func(ctx *next.HandlerCxt) {
      ctx.Response.AppendBodyString(`Hello`)
      ctx.Next()
    })
```

::: tip Слоенный подход 
Каждый слой имеет 1 определенную зону отвественности, это позволяет оставаться вашему коду простым и чистым.
Слой может самостоятельно создать http response и не передавать управление следующему слою. Например слой, который
проверяет аунтификацию, может сам создать http response с статус кодом `401`. С таким подходом, мы можем очень быстро обрабатывать некоторые запросы.

Другой пример, это обработчик, который может кешировать запрос и повторно очень быстро отвечать на запрос из кеша.
:::

### Options

Опции объекта Layer

| Опция            | Описание                                                                                                                                                                | По умолчанию        | Пример значения  |
|------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------|------------------|
| **Path**         | описывает uri путь, на который должен активироваться слой, можро использловать регулярки, без указария этого параметра слой активируется на любой uri                   | -                   | `/users/{id}/`   |
| **Name**         | определяем уникальное имя слоя, через это имя можно будет найти слой (по умолчанию все слои получают имена вида `l-0`, `l-1`, `l-2`, и т.д.)                            | -                   | `usersAction`    |
| **Methods**      | принимает slice из http методов, слой активируется только на http запросы с указанными http методами. Если методы не переданы, то слой активируется на любой http метод | `[]`                | `['GET']`        |
| **Priority**     | принимает `int` число с приоритетом, чем ни меньше число, тем раньше выполнится слой. Это позволяет конфигурировать слои декларативно, не в порядке добавления          | `0`                 | `100`            |
| **Restrictions** | принимает массив вида ['id' => \id+], позволяя накладывать дополнительные ограничения на переменны в uri запроса                                                        | `map[string]string` | `['id'=>'\d+']`  |
| **Meta**         | позволяет прикрепить к слою любые произволные данные                                                                                                                    | `map[string]any`    | `['foo'=>'bar']` |

Пример использования options в коде:
@[code{0-} go{19-27}](../../examples/layer-options.go)

### Fast http methods

Для упрощения также доступны методы, которые зеркалируют основные http методы, например:

```go
app := next.NewApp()

handler := func(ctx *next.HandlerCxt) {
    ctx.Next()
})

app.
	Get(`/users/{id}/`, handler).
	Post(`/users/{id}/`, handler).
	Put(`/users/{id}/`, handler).
	Patch(`/users/{id}/`, handler).
	Delete(`/users/{id}/`, handler)
```

### Декларативная кофнигурация

Очень удобно конфигурировать маршруты и порядок декларативно, например посредством yml файлов, простой пример такой
конфигурации может выглядить так:

```yml
# middlewares
ThrowableToResponse:
  controller: xxx

# 404 page
otherwise:
  handler: xxx
  name: otherwise
  priority: 10000

# actions
main:
  path: /
  methods: [ 'GET' ]
  handler: xxx

posts:
  path: /post/
  methods: [ 'GET' ]
  handler: xxx

cat:
  path: /cat/{id}/
  restrictions:
    id: \d+
  methods: [ 'GET' ]
  handler: xxx
```

Микрофреймворт не посталвядет фабрику слоев, чтобы не ограничивать синтаксис декларативной конфигурации.
Написать такую фабрику это тривиальная задача, пример:

@[code{0-} go](../../examples/layer-factory.go)

### Inline ограничения параметров в uri

Ограничения на параметр в `Path` можно описать дополнительно прямо в `Path` помимо конфигурации опции `Restrictions` у слоя.
Inline формат записи проще для простых регулярок. Для сложных и длинных регулярок лучше использовать явно опцию `Restrictions`, чтобы конфигурация слоя оставалась простой для чтения и интерпритации.
В общем виде такая форма записи выглядит так `{name:restrictRegExp}`.
Следующие конфигурации будут эквивалентны:

```yml
cat:
  path: /cat/{id}/
  restrictions:
    id: \d+

cat2:
  path: /cat/{id:\d+}/
```

::: tip Приоритет
Inline ограничения будут проигнорированы, если этот параметр сконфигурирован через опцию `Restrictions`
:::


### Flow

Каждый слой может что-то делать до вызова `ctx.Next()` на этапе запроса, также может что-то делать после вызова `ctx.Next()`
на этапе ответа. Пример полного выполнения запроса, который проходит сквозь все слои:

![200 flow](/img/layers/200.png?style=centerme)

Пример flow, кога запрос досрочно может быть обработан одним из слоев, без делегирования обработки через `ctx.Next()`:

![401 flow](/img/layers/401.png?style=centerme)
<!--
```yml
@startuml
scale 1.3
title: 401 response

Client -> App: http request
    activate App
    App -> "Auth Layer": request
    
        activate "Auth Layer"
        "Auth Layer" -> App: 401 response
        deactivate "Auth Layer"
    
    App -> Client: http response
    deactivate App
@enduml
```
-->

Каждый слой решает сам, создать http response и пректатить обработку, либо вызвать следующий слой и делегировать ему
тем самым обработку.

## Fasthttp

### Integration
Приложение реализует интерфейс обработчика `fasthttp.RequestCtx`. За счет этого оно может
интегрировться в любые приложения fasthttp как middleware, принимая на вход `fasthttp.RequestCtx`.

Схематично это выглядит как `fasthttp` -> `fasthttp` -> `next` -> `fasthttp`. 

---

Если микро приложение должно делегировать обработку запроса далее в классическое `fasthttp` приложение, то можно обернуть в такую middleware:

@[code{0-} go{45-47}](../../examples/next-in-fasthttp/next-in-fasthttp.go)

Такие интеграции позволяют точечно заменять части старого приложения или переносить небольшими кусочками часть функционала.



## net/http mux

### Adapter
Можно использвать обработчики в формате [http.HandleFunc](https://pkg.go.dev/net/http#HandlerFunc) через адаптер

@[code{0-} go{45-47}](../../examples/http-mux-adapter.go)

