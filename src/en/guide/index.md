# Quick Start

[[toc]]
---

::: tip Предыстория
Next является портированой версией микрофреймворка [php-next2](https://github.com/alexpts/php-next2).
:::

## Hello World

Минимальное приложение выглядит так:

@[code go{11-15}](../../examples/hello-world.go)

## Glossary

#### Middleware

Middleware - это часть приложения, которая отвечает за конкретную единицу логики в обработке
request/response.


#### Layer

Это абстракция которая является по сути middleware. Layer может иметь как 1 обработчик, так и несколько, чтобы декомпозировать на более мелкие части код.


#### Application

Приложение является самым высоким уровнем и реалзиует полноую обработку запроса.
Приложение это набор Layers, которые определяются для каждого http запроса индивидуально.
Задача приложения получить на входе http request и создать http response.

Приложение осознано сводит число сущностей к минимуму, чтобы оставаться действительно простым, понятным и надежным.
Основное понятие с которым придется постоянно работать это Layer (Слой).

Приложеине получает на вход объект `fasthttp.RequestCtx` и прогоняет через все обработчики слоев. Какие именно
слои примут частие в обработке запроса определяется метаифнормацией слоя. Семантически можно выделить следующие типы
слоев:

- Активация на любом запросе
- Активация по http методу
- Активация по соответствию uri в регулярном выражении
- Актичация по кастомной стратегии

::: details Собственные стратегии
Из коробки идет минимальный набор стратений (по http методу и поиск по uri). Можно дополнительно реализовать любые
кастомные правила, по которым будет принято решение активировать ли слоя для обработки запроса или нет. Для этого нужно
добавить свою реализацию `next.ResolverContract`
:::

## Layers Store

Приложение `MicroApp` хранит в себе в свойстве `LayersStore` хранилище слоев.
Хранилище слоев позволяет добавлять обрабочтики к приложению посредством методов `Use`, `AddLayer`, `Get`, `Post` и др :

```go
    app := NewApp()
	
    app.LayersStore.Use(layer.Config{}, func(ctx *layer.Ctx) error {
      ctx.FCtx.Response.AppendBodyString(`Hello`)
      return nil
    })
```

### Handler

Функция обработчик в общем случае принмает 1 аргумент.

```go
type Handler func(ctx *layer.Ctx) error {}
```

::: tip Context
Контекст - это связующая часть между всеми слоями. Базовый контекст хранит request, response и позволяет получить доступ
к текущему слою (Layer) в runtime. В контексте можно хранить все что угодно, ~~расширяя его дочерним классом и не
ограничивая себя~~.
:::

Чтобы делегировать управление следующему обработчику, нужно вызвать метод `Next` на объекте контекста:
```go
    app := NewApp()

    app.LayersStore.Use(layer.Config{}, func(ctx *layer.Ctx) error {
      ctx.FCtx.Response.AppendBodyString(`Hello`)
      return ctx.Next()
    })
```

::: tip Слоенный подход
Каждый слой имеет 1 определенную зону отвественности, это позволяет оставаться вашему коду простым и чистым.
Слой может самостоятельно создать http response и не передавать управление следующему слою. Например слой, который
проверяет аунтификацию, может сам создать http response с статус кодом `401`. С таким подходом, мы можем очень быстро обрабатывать некоторые запросы.

Другой пример, это обработчик, который может кешировать запрос и повторно очень быстро отвечать на запрос из кеша.
:::

### Options

Опции объекта Layer

| Опция            | Описание                                                                                                                                                                 | По умолчанию | Пример значения  |
|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------|------------------|
| **Path**         | описывает uri путь, на который должен активироваться слой, можро использловать регулярки, без указария этого параметра слой активируется на любой uri                    | -            | `/users/{id}/`   |
| **Name**         | определяем уникальное имя слоя, через это имя можно будет найти слой (по умолчанию все слои получают имена вида `l-0`, `l-1`, `l-2`, и т.д.)                             | -            | `usersAction`    |
| **Methods**      | принимает массив из http методов, слой активируется только на http запросы с указанными http методами. Если методы не переданы, то слой активируется на любой http метод | `[]`         | `['GET']`        |
| **Priority**     | принимает `int` число с приоритетом, чем ни меньше число, тем раньше выполнится слой. Это позволяет конфигурировать слои декларативно, не в порядке добавления           | `50`         | `100`            |
| **Restrictions** | принимает массив вида ['id' => \id+], позволяя накладывать дополнительные ограничения на переменны в uri запроса                                                         | `[]`         | `['id'=>'\d+']`  |
| **Context**      | позволяет прикрепить к слою любые произволные данные                                                                                                                     | `[]`         | `['foo'=>'bar']` |

Пример использования options в коде:
@[code{0-} go{19-27}](../../examples/layer-options.go)

### Fast http methods

Для упрощения также доступны методы, которые зеркалируют основные http методы, например:

```go
app := NewApp()

handler := func(ctx *layer.Ctx) error {
    return ctx.Next()
})

app.LayersStore.
	Get(`/users/{id}/`, handler).
	Post(`/users/{id}/`, handler).
	Put(`/users/{id}/`, handler).
	Patch(`/users/{id}/`, handler).
	Delete(`/users/{id}/`, handler)
```

### Declarative configuration

Очень удобно конфигурировать маршруты и порядок декларативно, например посредством yml файлов, простой пример такой
конфигурации выглядит так:

```yml
# middlewares
  @todo добавить пример

# 404 page
  @todo добавить пример

# actions
  @todo добавить пример
```

Можно написать свою стратегию, по которой декларативно будет настроены слои, посредством реалзиации `FactoryContract`

### Flow

Каждый слой может что-то делать до вызова `ctx->Next()` на этапе запроса, также может что-то делать после вызова `ctx->Next()`
на этапе ответа. Пример полного выполнения запроса, который проходит сквозь все слои:

![200 flow](/img/layers/200.png?style=centerme)

Пример flow, кога запрос досрочно может быть обработан одним из слоев, без делегирования обработки через `ctx->Next()`:

![401 flow](/img/layers/401.png?style=centerme)
<!--
```yml
@startuml
scale 1.3
title: 401 response

Client -> App: http request
    activate App
    App -> "Auth Layer": request
    
        activate "Auth Layer"
        "Auth Layer" -> App: 401 response
        deactivate "Auth Layer"
    
    App -> Client: http response
    deactivate App
@enduml
```
-->

Каждый слой решает сам, создать http response и пректатить обработку, либо вызвать следующий слой и делегировать ему
тем самым обработку.

## Fasthttp

### Integration
Приложение реализует интерфейс обработчика `fasthttp.RequestCtx`. За счет этого оно может
интегрировться в любые приложения fasthttp как middleware, принимая на вход `fasthttp.RequestCtx`.

Схематично это выглядит как `fasthttp` -> `fasthttp` -> `next`.

---

Если микро приложение должно делегировать обработку запроса далее в классическое `fasthttp` приложение, то можно обернуть в такую middleware:

@[code{0-} go{44-46}](../../examples/fasthttp-middelware.go)

Схематично это выглядит как `fasthttp (handler1)` -> `next` -> `fasthttp (handler2)` -> `fasthttp (handler 3)`.

Такие интеграции позволяют точечно заменять части старого приложения или переносить небольшими кусочками часть функционала.
